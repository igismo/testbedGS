#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2009 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use English;
use Getopt::Std;

# tbprerun

# This is the first program in the
# tbprerun/tbswapin/tbswapout/.../tbend sequences.  It's main purpose
# is to interpret the NS file and create the appropriate entries in
# virt_nodes and virt_lans.  After this script ends successfully the
# NS file is no longer necessary.
#
sub usage()
{
    print STDERR "Usage: $0 [-f] -e eid nsfile\n";
    exit(-1);
}
## GORAN: G option added to handle experiment creation 
## from the graphic envirionment/client using .xml file 
## instead of .ns files
my $optlist = "Gfze:";
my $pideid;
my $force   = 0;
my $zeemode = 0;
my $zeeopt  = "";

#
# Configure variables
#
my $TBROOT   = "/usr/testbed";
my $TESTMODE = 0;
my $TBLOGS   = "testbed-logs\@minibed.deterlab.net";
my $NSVERIFY = 0;
my $vtopgen  = "$TBROOT/bin/vtopgen";
my $batchexp = "$TBROOT/bin/batchexp";
my $template = "$TBROOT/lib/ns2ir/elabinelab.ns";
my $endexp   = "$TBROOT/bin/endexp";

# Untaint the path
$ENV{'PATH'} = "/usr/bin:/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/libexec/vis:$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "/usr/testbed/lib";
use libdb;
use libtestbed;
use libtblog;
use User;
use Experiment;
use Template;

#
# Turn off line buffering on output
#
$| = 1;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"e"})) {
    $pideid = $options{"e"};
    # Minimal error checking on pideid and untaints it
    $pideid =~ /([^;&]+)/;
    $pideid = $1;
}
if (defined($options{"z"})) {
    $zeemode = 1;
    $zeeopt  = "-p";
}
### GORAN add option G if specified
my $xmlfile = " ";
if (defined($options{"G"})) {
    $xmlfile = " -G ";
    print "Running TBPRERUN with -G option for xml file ... \n";
}
if (!defined($pideid) || @ARGV != 1) {
    usage();
}
my ($nsfile) = @ARGV;

# Minimal error checking on nsfile and untaints it
$nsfile =~ /([^;&]+)/;
$nsfile = $1;

if (! -r $nsfile) {
    tbdie("NS File '$nsfile' does not exist!");
}

#
# Verify user and get his DB uid and other info for later.
#
my $this_user = User->ThisUser();
if (! defined($this_user)) {
    tbdie("You ($UID) do not exist!");
}

# Slowly convert to using Experiment module.
my $experiment = Experiment->Lookup($pideid);
if (!defined($experiment)) {
    tbdie("Could not lookup experiment object for $pideid!");
}
# Need these below.
my $pid      = $experiment->pid();
my $eid      = $experiment->eid();
my $state    = $experiment->state();
my $gid      = $experiment->gid();
my $exptidx  = $experiment->idx();
my $instance;

print "Beginning pre run for $pid/$eid. " . TBTimeStamp() . "\n";
TBDebugTimeStamp("tbprerun started");

#
# Cleanup if something goes wrong.
#
sub cleanup {
    print STDERR "Cleaning up after errors.\n";
    if ($state eq EXPTSTATE_PRERUN) {
	# Must kill the prerender process before we remove virt state.
	print "Killing the renderer.\n";
	system("prerender -r $pid $eid");
    }
    print "Removing experiment state.\n";
    $experiment->RemoveVirtualState();
}

#
# Fatal error.
#
sub fatal($;$)
{
    my $parms = {};
    $parms = shift if ref $_[0] eq 'HASH';
    my ($mesg) = @_;
    
    cleanup();
    tbdie($parms, $mesg);
}

# Must kill any prerender process first!
system("prerender -r $pid $eid");

# Kill old virtual state.
$experiment->RemoveVirtualState() == 0 or
    tbdie("Could not remove virtual state!");

# This setups virt_nodes, virt_names including all IP address calculation
# and tb-* handling.
print "Running parser ... " . TBTimeStamp() . "\n";
TBDebugTimeStamp("parser started");
if (system("parse-ns $xmlfile $zeeopt $pid $gid $eid $nsfile")) {
    fatal({type => 'secondary', severity => SEV_SECONDARY,
	   error => ['ns_parse_failed']},
	  "Parsing failed!");
}
TBDebugTimeStamp("parser finished");
print "Parser done! " . TBTimeStamp() . "\n";

#
# XXX Until link agent runs on linux.
#
my $events_result =
    DBQueryFatal("select ev.pid,ev.eid,vl.vnode,vl.vname,vn.osname,o.OS ".
		 "  from eventlist as ev ".
		 "left join event_objecttypes as ev_ob on ".
		 "  ev.objecttype=ev_ob.idx ".
		 "left join virt_lans as vl on vl.vname=ev.vname and ".
		 "  vl.pid=ev.pid and vl.eid=ev.eid ".
		 "left join virt_nodes as vn on vn.pid=ev.pid and ".
		 "  vn.eid=ev.eid and vn.vname=vl.vnode ".
		 "left join os_info as o on o.osname=vn.osname and".
		 "  (o.pid=ev.pid or o.pid='emulab-ops') ".
		 "left join experiments as e on e.pid=ev.pid and ".
		 "  e.eid=ev.eid ".
		 "where ev.pid='$pid' and ev.eid='$eid' and ".
		 "  (vl.uselinkdelay!=0 or e.uselinkdelays!=0 or ".
		 "   e.forcelinkdelays!=0) and ev_ob.type='LINK' and ".
		 "  (o.os is NULL or o.os='Linux' or o.os='Fedora')");
if ($events_result->num_rows) {
    fatal("Oops, cannot send static events to linkdelay agents on Linux!");
}

#
# Only admins can set the sharing mode on nodes.
#
my $query_result =
    DBQueryFatal("select sharing_mode from virt_nodes ".
		 "where pid='$pid' and eid='$eid' and ".
		 "      sharing_mode is not null");
if ($query_result->numrows &&
    !($this_user->IsAdmin() || $this_user->uid eq "elabman")) {
    fatal("Only testbed admininstrators can set the sharing mode on nodes");
}

#
# Put the nsfile into the DB, now that we know it parses okay.
#
$experiment->SetNSFile($nsfile) == 0 or
    fatal("Error storing the NS file into the database!");

#
# In update mode, do not start the renderer until later. If update fails we
# want to try to restore old render info rather then rerunning. 
# 
if ($state eq EXPTSTATE_PRERUN && !$zeemode) {
    TBDebugTimeStamp("prerender started in background");
    print "Precomputing visualization ...\n";
    system("prerender -t $pid $eid");
}

#
# See if using the new ipassign.
#
if ($experiment->use_ipassign()) {
    my $ipassign_args  = $experiment->ipassign_args();

    if (! defined($ipassign_args)) {
	$ipassign_args = "";
    }
    TBDebugTimeStamp("ipassign_wrapper started");
    print "Doing IP assignment ...\n";
    
    if (system("ipassign_wrapper $ipassign_args $pid $eid")) {
	fatal("ipassign_wrapper failed!");
    }
}

#
# Fire up the route calculator. 
#
if (!$zeemode) {
    TBDebugTimeStamp("static route calculator started");
    print "Setting up static routes (if requested) ... \n";

    if (system("staticroutes $pid $eid")) {
	fatal({type => 'secondary', severity => SEV_SECONDARY,
	       error => ['static_routes_failed']},
	      "Static route calculation failed!");
    }
}

#
# Generate a topo map that is used by the remote nodes to create the
# routes (ddijk) and the /etc/hosts file.
#
TBDebugTimeStamp("gentopofile started");
print "Generating topomap ...\n";

if (system("gentopofile $pid $eid")) {
    fatal("gentopofile failed!");
}
## GORAN: Do this only if .ns file is supplied
## do not use with .xml specifications
if ($NSVERIFY && !$experiment->elabinelab() && ($xmlfile eq " ")) {
    TBDebugTimeStamp("verify-ns started");
    print "Verifying parse ...\n";
    
    if (system("verify-ns $pid $gid $eid $nsfile")) {
	if (1) {
	    SENDMAIL($TBLOGS,
		     "NS Verify failure for $pid/$eid",
		     "'verify-ns' failed for $pid/$eid\n".
		     "\nIf it is not a user error nstb_compat.tcl is ".
		     "probably out of date.\n");
	}
	else {
	    fatal({type => 'secondary', severity => SEV_SECONDARY,
		   error => ['ns_verify_failed']},
		  "verify-ns failed!");
	}
    }
}

#
# Do an assign_prerun to set the min/max nodes. Generates a top file too.
# This is the only DB state that is modified during a top only run.
#
if (!$zeemode) {
	
    my $cmd = "$vtopgen -p $pid $eid";
    TBDebugTimeStamp("assign prerun started");
    print "Doing a pre-assign: '$cmd' ...\n";

    if (system($cmd)) {
	fatal({type => 'secondary', severity => SEV_SECONDARY,
	       error => ['vtopgen', undef]},
	      "assign prerun failed!");
    }
}

#
# This stats stuff is not done in testmode.
# 
if (! $TESTMODE) {
    #
    # Deal with ElabInElab stuff, which is updated after the parse and prerun.
    # Want to move this to the stats records. Ditto for the security stuff,
    # which was handled above.
    #
    my %sets = ();

    $sets{"elabinelab"} = 1
	if ($experiment->elabinelab());
    $sets{"security_level"} = $experiment->security_level()
	if ($experiment->security_level());
    $sets{"elabinelab_exptidx"} = $experiment->elabinelab_exptidx()
	if (defined($experiment->elabinelab_exptidx()));

    if (keys(%sets)) {
	$experiment->TableUpdate("experiment_stats", \%sets) == 0 or
	    fatal("Could not update experiment_stats info for $experiment!");
    }
}

# Setup env variables.
if ($experiment->IsInstance()) {
    $instance->InitializeEnvVariables() == 0
	or fatal("Could not initialize environment strings variables");
}
else {
    $experiment->InitializeEnvVariables() == 0
	or fatal("Could not initialize environment strings variables");
}

print "Writing environment strings ...\n";
$experiment->WriteEnvVariables() == 0
    or fatal("Could not write environment strings for program agents");

print "Setting up additional program agent support ...\n";
$experiment->SetupProgramAgents() == 0
    or fatal("Could not setup program agent support");

print "Setting up additional network agent support ...\n";
$experiment->SetupNetworkAgents() == 0
    or fatal("Could not setup network agent support");

print "Writing program agent info ...\n";
$experiment->WriteProgramAgents() == 0
    or fatal("Could not write program agent info");

TBDebugTimeStamp("tbprerun finished");
print "Pre run finished. " . TBTimeStamp() . "\n";
exit(0);

